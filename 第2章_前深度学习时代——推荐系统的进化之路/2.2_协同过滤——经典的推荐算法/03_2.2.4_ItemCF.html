
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>03_2.2.4_ItemCF</title>
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css">
</head>
<body>
  <div class="container">
    <h1>03_2.2.4 ItemCF</h1>
<p>&quot;&quot;&quot;
Lecture: 第2章 前深度学习时代——推荐系统的进化之路/2.2 协同过滤——经典的推荐算法
Content: 03_2.2.4 ItemCF
&quot;&quot;&quot;</p>
<h3>2.2.4 ItemCF</h3>
<h4>1. 概述</h4>
<p>ItemCF（基于物品的协同过滤）是一种利用物品之间的相似度进行推荐的协同过滤算法。不同于UserCF（基于用户的协同过滤），ItemCF通过分析用户对物品的评分数据，计算物品之间的相似度，从而为用户推荐相似的物品。ItemCF被广泛应用于实际的推荐系统中，如Amazon和Netflix。</p>
<h4>2. ItemCF的工作原理</h4>
<p>ItemCF的核心思想是：如果一个用户喜欢某个物品A，并且A与物品B相似，那么这个用户很可能也会喜欢物品B。具体步骤如下：</p>
<h5>2.1 构建共现矩阵</h5>
<p>首先，基于历史数据，构建一个以用户为行坐标，物品为列坐标的共现矩阵。假设用户总数为m，物品总数为n，则共现矩阵是一个m×n的矩阵，其中矩阵的每个元素表示某个用户对某个物品的评分。</p>
<h5>2.2 计算物品相似度</h5>
<p>然后，计算共现矩阵中两两物品列向量之间的相似度。相似度的计算方法与用户相似度的计算方法相同，常用的有余弦相似度、皮尔逊相关系数等。通过这些计算，构建出一个n×n的物品相似度矩阵。</p>
<h5>2.3 获得用户历史行为数据</h5>
<p>获取用户历史行为数据中的正反馈物品列表。正反馈通常是指用户对某些物品的高评分或者购买记录。</p>
<h5>2.4 找出相似物品</h5>
<p>利用物品相似度矩阵，针对目标用户历史行为中的正反馈物品，找出相似的Top k个物品，组成相似物品集合。</p>
<h5>2.5 生成推荐列表</h5>
<p>对相似物品集合中的物品，根据相似度分值进行排序，生成最终的推荐列表。在这一过程中，如果一个物品与多个用户行为历史中的正反馈物品相似，那么该物品最终的相似度应该是多个相似度的累加。</p>
<p>公式如下：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mtext><mi mathvariant="normal">S</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">m</mi></mtext><mrow><mtext><mi mathvariant="normal">i</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">m</mi></mtext></mrow></msub><mo>(</mo><mi>p</mi><mo separator="true">,</mo><mi>q</mi><mo>)</mo><mo>=</mo><msub><mo>∑</mo><mrow><mi>h</mi><mo>∈</mo><mi>H</mi></mrow></msub><msub><mi>w</mi><mrow><mi>p</mi><mo separator="true">,</mo><mi>h</mi></mrow></msub><mo>⋅</mo><msub><mi>R</mi><mrow><mi>u</mi><mo separator="true">,</mo><mi>h</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\text{Sim}_{\text{item}}(p, q) = \sum_{h \in H} w_{p, h} \cdot R_{u, h} 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.050005em;"></span><span class="strut bottom" style="height:2.3794880000000003em;vertical-align:-1.329483em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord"><span class="text mord displaystyle textstyle uncramped"><span class="mord mathrm">S</span><span class="mord mathrm">i</span><span class="mord mathrm">m</span></span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="text mord scriptstyle cramped"><span class="mord mathrm">i</span><span class="mord mathrm">t</span><span class="mord mathrm">e</span><span class="mord mathrm">m</span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">p</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.03588em;">q</span><span class="mclose">)</span><span class="mrel">=</span><span class="mop op-limits"><span class="vlist"><span style="top:1.202113em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">h</span><span class="mrel">∈</span><span class="mord mathit" style="margin-right:0.08125em;">H</span></span></span></span><span style="top:-0.000005000000000032756em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span><span class="op-symbol large-op mop">∑</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.02691em;">w</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02691em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">p</span><span class="mpunct">,</span><span class="mord mathit">h</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">⋅</span><span class="mord"><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.00773em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">u</span><span class="mpunct">,</span><span class="mord mathit">h</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span></p>
<p>其中，$ H 是目标用户的正反馈物品集合， w_{p, h} $是物品 $ p $与物品 $ h 的相似度， R_{u, h} $是用户 $ u $对物品 $ h $的已有评分  。</p>
<h4>3. ItemCF的优缺点分析</h4>
<h5>优点</h5>
<ol>
<li><strong>数据稀疏性较小</strong>：与UserCF相比，物品数通常小于用户数，因此物品相似度矩阵的存储开销较小。</li>
<li><strong>推荐准确度高</strong>：ItemCF通过物品相似度进行推荐，能够捕捉用户的长期兴趣，适用于用户兴趣变化较慢的场景。</li>
</ol>
<h5>缺点</h5>
<ol>
<li><strong>冷启动问题</strong>：对于新物品，由于缺乏用户的评分数据，难以计算其相似度，从而无法推荐。</li>
<li><strong>实时性较差</strong>：由于需要计算物品之间的相似度，处理大规模数据时，计算复杂度较高，实时性较差。</li>
</ol>
<h4>4. ItemCF的应用场景</h4>
<p>ItemCF适用于用户兴趣相对稳定，物品类别较多的场景。例如：</p>
<ol>
<li><strong>电商网站</strong>：如Amazon，用户在一个时间段内倾向于寻找某一类商品，利用物品相似度进行推荐。</li>
<li><strong>视频推荐</strong>：如Netflix，用户观看电影、电视剧的兴趣点较为稳定，利用ItemCF推荐风格、类型相似的视频  。</li>
</ol>
<h3>结论</h3>
<p>ItemCF作为一种经典的推荐算法，通过计算物品之间的相似度进行推荐，解决了UserCF在数据稀疏性和扩展性上的问题。然而，ItemCF同样面临冷启动和计算复杂度高的问题。在实际应用中，可以结合多种推荐算法，如混合推荐系统，进一步提高推荐的准确性和用户体验。</p>
<hr>

  </div>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"></script>
  <script>
    document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        delimiters: [
          {left: "$$", right: "$$", display: true},
          {left: "$", right: "$", display: false},
          {left: "\(", right: "\)", display: false},
          {left: "\[", right: "\]", display: true}
        ]
      });
    });
  </script>
</body>
</html>
  