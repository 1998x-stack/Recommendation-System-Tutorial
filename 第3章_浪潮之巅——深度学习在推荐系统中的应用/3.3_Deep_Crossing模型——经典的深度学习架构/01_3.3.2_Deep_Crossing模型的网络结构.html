
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>01_3.3.2_Deep_Crossing模型的网络结构</title>
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css">
</head>
<body>
  <div class="container">
    <h1>01_3.3.2 Deep Crossing模型的网络结构</h1>
<p>&quot;&quot;&quot;
Lecture: 第3章 浪潮之巅——深度学习在推荐系统中的应用/3.3 Deep Crossing模型——经典的深度学习架构
Content: 01_3.3.2 Deep Crossing模型的网络结构
&quot;&quot;&quot;</p>
<h3>Deep Crossing模型的网络结构</h3>
<h4>一、引言</h4>
<p>Deep Crossing模型是微软于2016年提出的一种深度学习架构，主要应用于推荐系统中。该模型通过多个神经网络层级，实现特征处理和点击率预估。以下将详细分析Deep Crossing模型的网络结构，包括各层的功能及其实现方式。</p>
<h4>二、Deep Crossing模型的网络结构概述</h4>
<p>Deep Crossing模型的网络结构主要包括四层：Embedding层、Stacking层、Multiple Residual Units层和Scoring层。每一层在特征处理和点击率预估中起着关键作用。</p>
<h4>三、网络结构详解</h4>
<h5>1. Embedding层</h5>
<p><strong>1.1 目的：</strong></p>
<ul>
<li>将稀疏的类别型特征转换成稠密的Embedding向量。</li>
</ul>
<p><strong>1.2 实现方法：</strong></p>
<ul>
<li><strong>类别型特征编码：</strong> 通过one-hot或multi-hot编码将类别型特征转换为稀疏向量。例如，某一类别型特征有1000个不同的值，one-hot编码后形成一个1000维的向量，其中只有一个元素为1，其他元素为0。</li>
<li><strong>Embedding矩阵：</strong> 使用可训练的Embedding矩阵将稀疏向量转换为低维稠密向量。假设输入的one-hot向量为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="bold">x</mi></mrow></mrow><annotation encoding="application/x-tex">\mathbf{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.44444em;"></span><span class="strut bottom" style="height:0.44444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathbf">x</span></span></span></span></span>，Embedding矩阵为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="bold">E</mi></mrow></mrow><annotation encoding="application/x-tex">\mathbf{E}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68611em;"></span><span class="strut bottom" style="height:0.68611em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathbf">E</span></span></span></span></span>，则Embedding向量为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="bold">E</mi></mrow><mo>⋅</mo><mrow><mi mathvariant="bold">x</mi></mrow></mrow><annotation encoding="application/x-tex">\mathbf{E} \cdot \mathbf{x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68611em;"></span><span class="strut bottom" style="height:0.68611em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathbf">E</span></span><span class="mbin">⋅</span><span class="mord textstyle uncramped"><span class="mord mathbf">x</span></span></span></span></span>。</li>
<li><strong>参数更新：</strong> 在模型训练过程中，Embedding矩阵的参数通过反向传播算法进行更新，以学习到更好的特征表示。</li>
</ul>
<p><strong>1.3 优点：</strong></p>
<ul>
<li><strong>降维处理：</strong> 将高维稀疏向量转换为低维稠密向量，降低了输入数据的维度，减少了计算开销。</li>
<li><strong>特征表达：</strong> Embedding向量能够捕捉类别型特征之间的潜在关系，提高了模型的表达能力。</li>
</ul>
<h5>2. Stacking层</h5>
<p><strong>2.1 目的：</strong></p>
<ul>
<li>将不同的Embedding特征和数值型特征拼接在一起，形成包含全部特征的新特征向量。</li>
</ul>
<p><strong>2.2 实现方法：</strong></p>
<ul>
<li><strong>特征拼接：</strong> 对于每一个输入样本，将其对应的多个Embedding向量和数值型特征向量进行拼接。例如，对于一个样本的输入特征，包括3个Embedding向量和5个数值型特征，则拼接后的特征向量维度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>d</mi><mn>1</mn></msub><mo>+</mo><msub><mi>d</mi><mn>2</mn></msub><mo>+</mo><msub><mi>d</mi><mn>3</mn></msub><mo>+</mo><mn>5</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(d_1 + d_2 + d_3 + 5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord"><span class="mord mathit">d</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit">d</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord"><span class="mord mathit">d</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">+</span><span class="mord mathrm">5</span><span class="mclose">)</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">d</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>为第i个Embedding向量的维度。</li>
<li><strong>输入新特征向量：</strong> 将拼接后的新特征向量作为神经网络的输入，进行后续的深度学习处理。</li>
</ul>
<p><strong>2.3 优点：</strong></p>
<ul>
<li><strong>特征整合：</strong> 通过将不同类型的特征整合在一起，模型能够同时利用类别型特征和数值型特征的信息，提高了推荐系统的准确性。</li>
<li><strong>灵活性强：</strong> Stacking层可以处理任意数量和类型的特征，使得模型具有较高的灵活性和适应性。</li>
</ul>
<h5>3. Multiple Residual Units层</h5>
<p><strong>3.1 目的：</strong></p>
<ul>
<li>实现特征之间的自动交叉组合，捕捉复杂的特征交互关系，增强模型的表达能力。</li>
</ul>
<p><strong>3.2 实现方法：</strong></p>
<ul>
<li><strong>残差结构：</strong> 采用残差结构，通过增加跳跃连接（skip connection），使得输入能够直接通过输出，解决了深层神经网络训练中梯度消失的问题。</li>
<li><strong>多层堆叠：</strong> 堆叠多个残差单元，模型能够逐层学习到更高阶、更复杂的特征交互关系。每一层的输出表示为：$$ \mathbf{y}_l = \mathbf{x}_l + \mathcal{F}(\mathbf{x}_l, \mathbf{W}_l) $$
其中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mrow><mi mathvariant="bold">x</mi></mrow><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">\mathbf{x}_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.44444em;"></span><span class="strut bottom" style="height:0.59444em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class=""><span class="mord textstyle uncramped"><span class="mord mathbf">x</span></span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.01968em;">l</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>是第l层的输入，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="script">F</mi></mrow><mo>(</mo><msub><mrow><mi mathvariant="bold">x</mi></mrow><mi>l</mi></msub><mo separator="true">,</mo><msub><mrow><mi mathvariant="bold">W</mi></mrow><mi>l</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{F}(\mathbf{x}_l, \mathbf{W}_l)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathcal" style="margin-right:0.09931em;">F</span></span><span class="mopen">(</span><span class=""><span class="mord textstyle uncramped"><span class="mord mathbf">x</span></span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.01968em;">l</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class=""><span class="mord textstyle uncramped"><span class="mord mathbf" style="margin-right:0.01597em;">W</span></span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.01968em;">l</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span>是通过非线性变换后的特征表示。</li>
</ul>
<p><strong>3.3 优点：</strong></p>
<ul>
<li><strong>特征交互：</strong> 通过多层残差单元的堆叠，模型能够自动学习特征之间的高阶交互关系，提高特征表达的丰富度。</li>
<li><strong>训练稳定：</strong> 残差结构的引入，使得深层网络的训练更加稳定，避免了梯度消失和梯度爆炸的问题。</li>
</ul>
<h5>4. Scoring层</h5>
<p><strong>4.1 目的：</strong></p>
<ul>
<li>作为输出层，通常使用逻辑回归模型进行CTR（Click-Through Rate）预估。</li>
</ul>
<p><strong>4.2 实现方法：</strong></p>
<ul>
<li><strong>线性变换：</strong> 将Residual Units层的输出通过线性变换映射到CTR的概率空间，通常采用Sigmoid激活函数将输出值映射到[0, 1]区间。</li>
<li><strong>损失函数：</strong> 采用交叉熵损失函数衡量模型的预测误差，通过反向传播算法优化模型参数。</li>
</ul>
<p><strong>4.3 优点：</strong></p>
<ul>
<li><strong>简单高效：</strong> Scoring层结构简单，计算效率高，适用于CTR预估等需要输出概率的推荐任务。</li>
<li><strong>优化目标明确：</strong> 通过优化交叉熵损失函数，Scoring层可以明确优化CTR预估的目标，提高模型的预测准确性。</li>
</ul>
<h3>总结</h3>
<p>Deep Crossing模型通过Embedding层和Stacking层将稀疏特征向量转换为稠密特征向量，通过Multiple Residual Units层实现特征的自动交叉组合，并通过Scoring层进行CTR预估。这种结构不仅解决了传统推荐系统在特征交叉和稀疏数据处理方面的挑战，还显著提高了模型的表达能力和预测准确性。以下是Deep Crossing模型的具体优势：</p>
<ol>
<li>
<p><strong>稀疏特征向量稠密化</strong></p>
<ul>
<li>降低计算复杂度，提高训练效率。</li>
<li>捕捉类别型特征之间的潜在关系，增强模型的表达能力。</li>
</ul>
</li>
<li>
<p><strong>特征自动交叉组合</strong></p>
<ul>
<li>通过多层残差单元自动学习特征之间的高阶交互关系，提升特征表达的丰富度。</li>
<li>提高模型的泛化能力，避免过拟合问题。</li>
</ul>
</li>
</ol>

  </div>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"></script>
  <script>
    document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        delimiters: [
          {left: "$$", right: "$$", display: true},
          {left: "$", right: "$", display: false},
          {left: "\(", right: "\)", display: false},
          {left: "\[", right: "\]", display: true}
        ]
      });
    });
  </script>
</body>
</html>
  